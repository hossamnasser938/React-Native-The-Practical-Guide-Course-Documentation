# Authentication in React Native Apps

## Module Introduction
* In this module we will have a look at how to:
    * **authenticate** users because we do not want to let **malicious** users **access** our application.
    * use ` Async Storage ` for **data persistence**.


## How Authentication works in React Native Apps
* There are **2 actors** in the scene of **authentication** in ` React Native `.
    * The **Server**  
    It provides, at least, 2 endpoints: One to signup a new user and the other to login an existing user. 
    * The ` React Native ` **App**  
    It simply sends the **server** a request holding **authentication** data like for example an email and a password. The **server** then validates this **authentication** data and on success it returns a **Token** which is encoded data generated by the **server** that can be used to prove that the user is **authenticated**. It is the responsibility of the server to ensure that this **Token** can not be **faked***. After getting this **Token** we, the ` React Native ` app, have to **persist** it as it will be **coupled** with any subsequent request to the server to access any resource like, in our case, sharing a place or fetching places. This **Token** also have a valid timestamp. After this timestamp passes, it is no longer valid and the server then will not consider it a valid **Token**. So it is the responsibility of the ` React Native ` app to request refreshing this **Token** from the server.


## Enabling Firebse Authentication
* We need the endpoints that we will use to **signup** and **login** users. For that, **google** for **Firebse Auth Rest Api**. There you find the endpoints you need. For each service, there is an endpoint, services such as ` Sign up with email / password ` and ` Sign in with email / password `.

* Before we can use these endpoints, we must enable the **authentication** method we will use in firebase project console. There in **Authentiction** section:
    1. Hit ` Setup sign-in method `.
    2. Enable ` Email/Password `.


## Signing Users Up
* Now let's use the ` Sign up with email / password ` endpoint which is ` https://www.googleapis.com/identitytoolkit/v3/relyingparty/signupNewUser?key=[API_KEY] `.

* Note tht we need to replce ` [API_KEY] ` with our project API key which can be found in firebase project console -> project settings -> Web API Key .

* By following the docs of ` Sign up with email / password ` service, we can find that we need to make a ` POST ` request and adding:
    * a ` body ` payload consisiting of:
        * ` email `.
        * ` password `.
        * ` returnSecureToken ` which should be always ` true `.
    Do not forget to ` JSON.stringify() ` the ` body ` payload object since ` body ` expects to get a ` string `.
    * a ` headers ` with ` "Content-Type" ` assigned ` "appliction/json" `.

* In ` redux/actions/auth.js ` we have ` authUser ` ` Action ` that we never respond to in a ` reducer `. We can turn this ` Action ` into an **async** ` Action ` where we use the ` fetch ` **Api** to sign user up.
```js
export const authUser = authData => {
    return dispatch => {
        fetch("https://www.googleapis.com/identitytoolkit/v3/relyingparty/signupNewUser?key=AIzaSyBFZStIFc7dBuUdndrnJ00kZuOdXOzDX8I", {
            method: "POST",
            body: JSON.stringify( {
                email: authData.email,
                password: authData.password,
                returnSecureToken: true
            } ),
            headers: {
                "Content-Type": "application/json"
            }
        })
        .catch( error => {
            console.log( "error: ", error );
            alert( "Authentication failed, please try agin!!" );
        } )
        .then( response => response.json() )
        .then( parsedResponse => {
            console.log( parsedResponse );
        } );
    }
};
```
We get an object wrapping the **Token** and a bunch of useful values. Now we only ` log ` them but later we will use these info.  
Note that the ` catch ` block ` catches ` only errors due to network. It does not ` catch ` **4xx** or **5xx** errors. These errors have to be checked in the ` then ` block.


## Using the Aythentication Result(Response)
* Till now we're successfully signing the user up but we're not doing anything with the response we're getting from firebase.

* We need to do 2 things:
    1. Show the user the ` ActivityIndicator ` while we are connecting to firebase. We already did that before using ` uiStartLoading ` and ` uiStopLoading ` ` Actions `. We follow the same approach which I will not repeat since it is exactly the same.

    2. Proceed to the Main tabs only when getting a success from firebase and throw an ` alert ` on getting errors.
        1. Do not call ` createMainTabs ` in ` AuthScreen `.
        ```js
        loginHandler = () =>  {
            const authData = {
                email: this.state.controls.email.value,
                password: this.state.controls.password.value
            }

            this.props.onLogin( authData );

            //createMainTabs();
        };  
        ```

        2. Instead in ` redux/actions/auth.js ` we want to check on getting the ` parsedResponse ` if it holds an error so we throw an ` alert ` or it holds success so we proceed to the main tabs from there.
        ```js
        import { AUTH_USER } from './ActionTypes';
        import { uiStartLoading, uiStopLoading } from './index';
        import createMainTabs from '../../screens/main_tabs/createMainTabs';

        export const authUser = authData => {
            return dispatch => {
                dispatch( uiStartLoading() );

                fetch("https://www.googleapis.com/identitytoolkit/v3/relyingparty/signupNewUser?key=AIzaSyBFZStIFc7dBuUdndrnJ00kZuOdXOzDX8I", {
                    method: "POST",
                    body: JSON.stringify( {
                        email: authData.email,
                        password: authData.password,
                        returnSecureToken: true
                    } ),
                    headers: {
                        "Content-Type": "application/json"
                    }
                })
                .catch( error => {
                    dispatch( uiStopLoading() );
                    console.log( "error: ", error );
                    alert( "Authentication failed, please try agin!!" );
                } )
                .then( response => response.json() )
                .then( parsedResponse => {
                    dispatch( uiStopLoading() );
                    console.log( parsedResponse );

                    if ( parsedResponse.error ) {
                        alert( "Authentication failed, please try agin!!" );
                    }
                    else {
                        createMainTabs();
                    }
                } );
            }
        }; 
        ```
        Note that we send a generic message to the user when an error occurred. However, in a real application, it will be much better to check the ` error.message ` and send a suitable message to the user based on the ` error.message `.


## Supporting Signup and Login && Adding User Login
* Till now we're only letting user **signup**. We need to let him/her **login** with an existing account.

* For that we can pass the ` authMode `, which we already have in our ` state ` in ` AuthScreen `, to ` authUser ` ` Action ` and there we configure the ` request ` we send to firebase to be either **signup** or **login**. Since the only thing that differentiate a **signup** from a **login** request is the **url** we can just configure this **url** and the rest of the code is still unchanged. If we looked at the documentation of firebase auth rest api, we can see that the ` body ` payload and the ` headers ` are the same for bot **signup** and **login** **APIs**.

* Let's update the ` Action ` we ` dispatch ` from ` AuthScreen ` to accept the ` authMode `.
```js
const mapDispatchToProps = dispatch => {
    return {
        onLogin: ( authData, authMode ) => {
            dispatch( authUser( authData, authMode ) );
        }
    };
};
```

```js
loginHandler = () =>  {
    const authData = {
        email: this.state.controls.email.value,
        password: this.state.controls.password.value
    }

    this.props.onLogin( authData, this.state.authMode );
};
```

* Let's configure our login in ` authUser ` ` Action `.
```js
import { AUTH_USER } from './ActionTypes';
import { uiStartLoading, uiStopLoading } from './index';
import createMainTabs from '../../screens/main_tabs/createMainTabs';

export const authUser = ( authData, authMode ) => {
    const API_KEY = "AIzaSyBFZStIFc7dBuUdndrnJ00kZuOdXOzDX8I";
    const SIGNUP_URL = "https://www.googleapis.com/identitytoolkit/v3/relyingparty/signupNewUser?key=";
    const LOGIN_URL = "https://www.googleapis.com/identitytoolkit/v3/relyingparty/verifyPassword?key=";

    return dispatch => {
        dispatch( uiStartLoading() );

        let url = authMode === "signup"
            ? SIGNUP_URL + API_KEY
            : LOGIN_URL + API_KEY;

        fetch(url, {
            method: "POST",
            body: JSON.stringify( {
                email: authData.email,
                password: authData.password,
                returnSecureToken: true
            } ),
            headers: {
                "Content-Type": "application/json"
            }
        })
        .catch( error => {
            dispatch( uiStopLoading() );
            console.log( "error: ", error );
            alert( "Authentication failed, please try agin!!" );
        } )
        .then( response => response.json() )
        .then( parsedResponse => {
            dispatch( uiStopLoading() );
            console.log( parsedResponse );

            if ( parsedResponse.error ) {
                alert( "Authentication failed, please try agin!!" );
            }
            else {
                createMainTabs();
            }
        } );
    }
};
```


## Protecting Routes on Firebase
* Now we provided a way for the user to **signup** and **login** so we do not want to let anyone access firebase protected resources unless he is authenticated. To do that we update the **rules** of firebase **realtime database** to let only **authenticated** users access it.
```js
{
  "rules": {
    ".read": "auth != null",
    ".write": "auth != null"
  }
}
```
Note that ` auth ` is a variable provided by firebase that when it equals ` null ` this means the user is not **authenticated**.

* If we tried now to ` getPlaces `, ` addPlace ` or ` deletePlace ` we are not allowed because we're not proving for firebase that we're authenticated. We already get the **Token** but we need to attach it with each request we make to firebase to prove that we are authenticated.

* We also notice that we get ` Unhandled Promise Rejection `. However, we do have a ` catch ` block immediately after ` fetch `, we do not get into this ` catch ` blocke, why? because the ` Promise ` returned from ` fetch ` only ` rejects ` on a **network error** when we can not reach the server and this is not the case. We're reaching the server but the server responds with an ` error `the ` Promise ` ` rejects ` after we get the ` response `. To solve that we need the ` catch ` block after the last ` then ` there to ` catch ` all possible errors. So we move the ` catch ` block of all **async** ` Actions ` after the last ` then `. 


## Storing the Auth Token in Redux
* Now we need to keep track of the **Token** to be coupled with all subsequent requests to firebase.

* Let's start by saving it into application ` state `. Later we will persist it into ` Async Storage `. We will create a new ` Action ` that accepts the ` token ` and the ` reducer ` will save it into the ` state `.
    1. Create a new ` Action ` name in ` redux/actions/ActionTypes.js `.
    ```js
    export const SET_TOKEN = "SET_TOKEN"; 
    ```
    2. create a new ` Action Creator ` in ` redux/actions/auth.js `.
    ```js
    export const setToken = token => {
        return {
            type: SET_TOKEN,
            payload: token
        }
    }
    ```
    ` dispatch ` this ` Action ` when getting the ` token ` in ` authUser ` ` Action `.
    ```js
    else {
        dispatch( setToken( parsedResponse.idToken ) );
        createMainTabs();
    }
    ```
    3. Create a new file named ` auth.js ` in ` redux/reducers ` to define the a ` reducer ` for ` auth ` ` Actions `.
    ```js
    import { SET_TOKEN } from "../actions/ActionTypes";

    const initialState = {
        token: null
    };

    const authReducer = ( state = initialState, action ) => {
        let coppiedState = {
            ...state
        };

        switch ( action.type ) {
            case SET_TOKEN:
                coppiedState.token = action.payload;
                break;
        }

        return coppiedState;
    } ;

    export default authReducer;
    ```

    4. `  combine ` this new ` reducer ` in ` configStore `.
    ```js
    import authReducer from './reducers/auth';

    const rootReducer = combineReducers( { PlacesReducer, uiReducer, authReducer } );
    ```


## Using the Auth Token
* Now we stored the **Token** in the global application ` state `, we need to attach it with our requests to access firebase protected resources including the realtime database as well as the storage.

* If we googled for ` Authenticate REST requests `, we find under section ` Authenticate with an ID token ` that all we need to do is to append to the **url** a query parameter with key ` auth ` and value the **Token**.

* Still there is one thing needed. We need to get access to the **Token** in ` Action Creators ` in which we ` addPlace `, ` deletePlace `, or ` getPlaces `. How can we access the ` state ` there? ` redux-thunk ` provides a nice feature. We normally return a ` function ` that accepts ` dispatch `. This ` function ` also can accept ` getState ` as a second argument. using ` getState ` we can access the global application ` state `.

* In ` redux/actions/places ` we can update ` getPlaces ` ` Action ` to use this nice feature.
```js
export const getPlaces = () => {
    return ( dispatch, getState ) => {
        const token = getState().authReducer.token;
        if ( !token ) {
            alert( "No token available!!" );
            return;
        }
        fetch("https://rn-course-practi-1553685361491.firebaseio.com/places.json?auth=" + token)
        .then( response => response.json() )
        // rest of the function
```


## Fetching the Token in a Reusable Way
* However, the previous approach works, we need a **reusable** approach. We can separate the logic of getting the ` token ` in a standalone ` Actuion `. But we need the ` Action ` to return immediately the ` token `. How can we acheive that? ` redux-thunk ` provides another nice feature. We can return a ` Promise ` from an ` Action ` that we can chain ` then ` and ` catch ` blocks. We define a new ` Action ` that returns a ` Promise ` that when ` resolves ` returns the ` token `. Let's try that:
    1. Add an ` Action ` name in ` redux/actions/ActionTypes.js `.
    ```js
    export const GET_TOKEN = "GET_TOKEN";
    ```
    
    2. Define a new ` Action Creator ` in ` redux/actions/auth.js `.
    ```js
    export const getToken = () => {
        return ( dispatch, getState ) => {
            const token = getState().authReducer.token;

            return new Promise( ( resolve, reject ) => {
                if ( !token ) {
                    reject();
                }
                
                resolve( token );
            } );
        };
    }; 
    ```

    3. ` export ` this new ` Action ` from ` redux/actions/index.js `.
    ```js
    export { authUser, getToken } from './auth';
    ```

    3. Use this ` Action ` in ` getPlaces ` ` Action `.
    ```js
    export const getPlaces = () => {
        return dispatch => {
            dispatch( getToken() )
                .catch( error => {
                    alert( "No token found!!" );
                } )
                .then( token => {
                    return fetch("https://rn-course-practi-1553685361491.firebaseio.com/places.json?auth=" + token)
                } )
                .then( response => response.json() )
                .then( parsedResponse => {
                    console.log( parsedResponse );
                    let places = [];

                    for ( let key in parsedResponse ) {
                        places.push( {
                            ...parsedResponse[key],
                            image: {
                                uri: parsedResponse[key].imageUrl
                            },
                            key: key
                        } );
                    }

                    dispatch( setPlaces( places ) );
                } )
                .catch( error => {
                    console.log( "error: ", error );
                    alert( "Error occurred!!" );
                } );
        }
    }
    ```

    4. Use this ` Action ` in ` deletePlace ` and ` addPlace ` however, in ` addPlace ` we are invoking the cloud function which has its own logic decoupled from the realtime database. So we have to specify ourselves how to authenticate cloud function REST.


## Protecting the Firebase Cloud Function && Adding Places(Authenticated)     
* The approach we used to authenticate our requests to the **firebase realtime database** is specified by firebase itself and we just followed the rules they put. However, this is not the case when it comes to **firebase cloud storage** since **we** are the party that specified the backend logic through our **cloud function** the we deployed. For that reason we have to decide on the logic that authenticate the user in the **cloud function**.

* Let's say that we won't send teh ` token ` as a **query parameter**. We will attach it as a property in ` headers ` payload. Inside ` headers ` our ` token ` will reside in a property named ` authorization `. We can enforce a prefix or a postfix on the ` token ` and we check that in the **cloud function** as the instructor did.

* In ` redux/actions/places.js ` in ` addPlace ` ` Action ` where we connect to our **cloud function** we will add our ` token ` in the way we discussed.
```js
export const addPlace = ( placeName, placeLocation, placeImage ) => {
    return dispatch => {
        dispatch ( uiStartLoading() );

        let authToken;

        dispatch( getToken() )
            .catch( error => {
                alert( "Could not find token!!" );
            } )
            .then( token => {
                authToken = token;
                return fetch( "https://us-central1-rn-course-practi-1553685361491.cloudfunctions.net/uploadImage", {
                    method: "POST",
                    body: JSON.stringify( { 
                        image: placeImage.base64 
                    } ),
                    headers: {
                        "authorization": authToken
                    }
                } )
            } )
            .then( response => response.json() )
            .then( parsedResponse => {
                const place = {
                    name: placeName,
                    location: placeLocation,
                    imageUrl: parsedResponse.imageUrl
                };

                return fetch("https://rn-course-practi-1553685361491.firebaseio.com/places.json?auth=" + authToken, {
                    method: "POST",
                    body: JSON.stringify( place )
                })
                .then( response => response.json() )
                .then( parsedResponse => { 
                    console.log( parsedResponse );
                    dispatch( uiStopLoading() ); 
                } );
            } )
            .catch( error => {
                console.log( "error: ", error );
                alert( "Something went wrong!!" );
                dispatch( uiStopLoading() );
            });
    }
};
```
Note that we saved the ` token ` in a variable because we will use it in the ` then ` block in which we push the place to the realtime database.

* Now let's add the logic of authenticating users in the **cloud function**. 
* We need the help of firebase to validate that ` token ` since firebase is the party that generated the ` token ` and thus firebase only can validate it.
* Firebase indeed provides a package named ` firebase-admin ` that provides some **admin** functionality in **cloud functions** including validating **tokens**. We can ` import ` this package
```js
const admin = require( "firebase-admin" );
```
We need to initialize it and inform it what our project is to be able to valicate **token** generated for our project.
```js
admin.initializeApp( {
    credential: admin.credential.cert( require("./credentials.json") )
} );
```
Note that we used the ` credentials.json ` file we downloaded before. This file contains the identity of the project and proves the we are the owner of the project.

* Now we have everything to validate a ` token `. All we have to do is to pass the ` token ` to ` admin.auth().verifyIdToken() ` and this returns a ` Promise ` that ` resolves ` with the ` token ` decoded and ` rejects ` if it is invalid. So we pass the ` token ` there and put all the rest of our code in the ` then ` block of the returning ` Promise `. But we first need to check whether ` headers ` has ` authorization ` that holds the ` token ` before we verify it. If it is not there we ` respond ` bu ` status ` ` 403 ` indicating ` access denied `.  
```js
exports.uploadImage = functions.https.onRequest((request, response) => {
    cors( request, response, () => {
        if ( !request.headers.authorization ) {
            console.log( "Token does not exist" );
            response.status( 403 ).json( { error: "Unauthorized" } );
        }

        const token = request.headers.authorization;

        admin.auth().verifyIdToken( token )
            .catch( error => {
                console.log( "Token is invalid" );
                response.status( 403 ).json( { error: "Unauthorized" } );
            } )
            .then( encodedToken => {
                const body = JSON.parse( request.body );

                fs.writeFileSync( "/tmp/image.jpg", body.image, "base64", error => {
                    console.log( "error: ", error );
                    return response.status( 500 ).json( { error } );
                } );

                const bucket = gcs.bucket( "rn-course-practi-1553685361491.appspot.com" );

                const name = uuid(); 

                bucket.upload( "/tmp/image.jpg", {
                    uploadType: "media",
                    destination: "/places/" + name + ".jpg",
                    metadata: {
                        metadata: {
                            contentType: "image/jpg",
                            firebaseStorageDownloadTokens: name
                        }
                    } 
                    }, ( error, file ) => {
                        if ( !error ) {
                            response.status( 201 ).json( {
                                imageUrl: "https://firebasestorage.googleapis.com/v0/b/" +
                                    bucket.name +
                                    "/o/" +
                                    encodeURIComponent( file.name ) +
                                    "?alt=media&token=" +
                                    name
                            } );
                        }
                        else {
                            console.log( "error: ", error );
                            response.status( 500 ).json( { error } );
                        }
                    }
                );
            } );
    } );    
});
```

* Now we can deploy our **cloud function** by hitting ` firebase deploy ` in the project root directory and test.


## Storing the Token in Async Storage
* Now we need to **persist** the ` token ` so that when the user closes and reopens the app, he/she should still be authenticated. We use the ` AyncStorage ` **Api** which provides a way to persist key-value pairs and depending on the platform, it will pick the suitable database for example in **Android** it may pick **SQL Lite**.

* It's called ` AsyncStorage ` because it works **asynchronously**. Any time you push or retreive from it, it returns a ` Promise `.

* ` AsyncStorage ` provides 4 useful methods[and more]:
    * ` setItem ` which pushes a key-value pair. It accepts 2 arguments:
        * ` key ` a unique string.
        * ` value `.
        * an optional callback that accepts ` error `.
    
    * ` getItem ` which retreives a value. It accepts 2 arguments
        * ` key `.
        * an optional callback that accepts ` error ` and ` result `.
    
    * ` removeItem ` which removes a key-value pair. It accepts 2 arguments:
        * ` key `.
        * an optional callback that accepts ` error `.

    * ` clear ` which removes all key-value pairs. It accepts 1 optional argument which is a callback that accepts ` error `.

* We need to define a new ` Action ` that stores the ` token ` in ` AsyncStorage `.
    1. In ` redux/actions/ActionTypes.js ` we define its name.
    ```js
    export const STORE_TOKEN = "STORE_TOKEN";
    ```

    2. We define it in ` redux/actions/auth.js `.
    ```js
    export const storeToken = token => {
        return dispatch => {
            dispatch( setToken( token ) );
            AsyncStorage.setItem("auth_token", token);
        }
    }
    ```
    Do not forget to ` import ` ` AsyncStorage ` from ` react-native ` and also the ` Action ` name from ` ActionTypes `. 

    3. Use ` storeToken ` instead of ` setToken ` in ` authUser ` ` Action ` when getting the ` token ` from firebase.

    4. in ` getToken ` ` Action ` when we do not find ` token ` in ` state ` we should look for it in ` AsyncStorage ` and if it found there it should be stored in ` state ` and ` resolve `.
    ```js
    export const getToken = () => {
        return ( dispatch, getState ) => {
            const token = getState().authReducer.token;

            return new Promise( ( resolve, reject ) => {
                if ( !token ) {
                    AsyncStorage.getItem( "auth_token" )
                        .then( tokenFromStorage => {
                            if ( !tokenFromStorage ){
                                dispatch( setToken( tokenFromStorage ) );
                                resolve( tokenFromStorage );
                            }
                            else {
                                reject();
                            }
                        } )
                        .catch( error => {
                            reject();
                        } )
                }
                else {
                    resolve( token );
                }
            } );
        };
    };
    ```

* I want to note down something here: Once A ` Promise ` is ` resolved ` or ` rejected ` any subsequent ` resolve ` or ` reject ` has no effect.


## Adding Auto Sign-In Functonality
* Now we store the ` token ` in ` AsyncStorage `, we wish to auto sign in the user when he/she has a ` token ` in ` AsyncStorage `. We will create an ` Action ` that ` dispatches ` ` getToken ` and if it there, it calls ` createMainTabs ` and we will ` dispatch ` this new ` Action ` in ` componentDidMount ` or ` componentWillMount ` of ` AuthScreen `. I think ` componentWillMount ` is better in this case. However, both of them are not optimal approaches because in both cases ` AuthScreen ` will appear and then magically it will go to main tabs which is strange for the user. I think the best approach is to check whether to start ` singleScreenApp ` [ Auth Screen] or ` tabBasedApp ` [main tabs]. The problem is that reaching ` AsyncStorage ` takes some time so may be the instructor will do that when adding a **splash screen**. Anyway we will stick with the instructor.
    1. Define the new ` Action ` in ` redux/actions/auth.js `.
    ```js
    export const autoSignIn = () => {
        return dispatch => {
            dispatch( getToken() )
                .then( token => {
                    createMainTabs();
                } )
                .catch( error => {
                    console.log( error );
                } );
        }
    }
    ```

    2. ` export ` this ` Action ` in ` redux/actions/index.js `.
    ```js
    export { authUser, getToken, autoSignIn } from './auth';
    ```

    3. Use it in ` AuthScreen.js `.
    ```js
    import { authUser, autoSignIn } from '../redux/actions/index';
    ```
    ```js
    const mapDispatchToProps = dispatch => {
        return {
            onLogin: ( authData, authMode ) => {
                dispatch( authUser( authData, authMode ) );
            },
            onAutoSignIn: () => dispatch( autoSignIn() )
        };
    };
    ```
    ```js
    componentDidMount() {
        this.props.onAutoSignIn();
    }
    ```


## Managing the Token Expiration
* The ` token ` we get from firebase has a valid timestamp after that timestamp, it is no longer valid. This timestamp is set by firebase and we get this timestamp in a property named ` expiresIn ` in the object we get when we login besides the ` idToken ` property. This time is ` 3600 ` in seconds. This equals an hour.

* What happens when this timestamp passes? we will still redirect the user to main tabs while when accessing resources the firebase will dismiss these requests and it is a terrible **user experience**. You tell the user that he/she is signed in while he is not.

* For now we want to not let the user proceed to the main tabs if the ` token ` has passed its valid time. Later we will add the functionality of refreshing the ` token `.

* For that we need first to store the date in which the ` token ` expires and when getting the ` token ` from ` AsyncStorage ` we check if it is still valid or not by comparing the expiry date with the current date.
    1. In ` authUser ` ` Action ` when calling ` storeToken ` ` Action ` to store the ` token `, we need to pass also ` expiresIn ` property.
    ```js
    dispatch( storeToken( parsedResponse.idToken, parsedResponse.expiresIn ) );
    ```

    2. In ` storeToken ` ` Action ` we need to generate and store the expiry date by adding to the current date  ` expiresIn ` after making suitable transformations.
    ```js
    export const storeToken = ( token, expiresIn ) => {
        return dispatch => {
            dispatch( setToken( token ) );
            AsyncStorage.setItem( "auth_token", token );

            const now = new Date();
            const expiryDateInMilliseconds = now.getTime() + expiresIn * 1000;

            AsyncStorage.setItem( "auth_expiryDate", expiryDateInMilliseconds.toString() );
        }
    }
    ```
    Note that ` now.getTime() ` converts a ` Date ` object into its milliseconds representation. Note also that ` AsyncStorage ` accepts ` string ` literals so we used ` toString ` method.

    3. In ` getToken ` ` Action ` if we got the ` token ` from ` AsyncStorage ` we need to get also the ` expiryDate ` and see if the ` token ` is still valid.
    ```js
    export const getToken = () => {
        return ( dispatch, getState ) => {
            const token = getState().authReducer.token;

            return new Promise( ( resolve, reject ) => {
                if ( !token ) {
                    let gotToken;

                    AsyncStorage.getItem( "auth_token" )
                        .then( tokenFromStorage => {
                            gotToken = tokenFromStorage;
                            if ( !gotToken ){
                                reject();
                                return;
                            }
                            return AsyncStorage.getItem( "auth_expiryDate" );
                        } )
                        .then( expiryDate  => {
                            const now = new Date();
                            const expiryDateObj = new Date( parseInt( expiryDate ) );
                            if ( now < expiryDateObj ) {
                                dispatch( setToken( gotToken ) );
                                resolve( gotToken );
                            }
                            else {
                                reject();
                            }
                        } )
                        .catch( error => {
                            reject();
                        } )
                }
                else {
                    resolve( token );
                }
            } );
        };
    }; 
    ```


##  Refreshing the Token
* Now we need to refresh the token if it has been expired. Firebase provides a REST service to exchange the ` refresh token ` with an ` id token `. Note that you get the ` refresh token ` when you login. 

* If we visited the Firebase Auth REST Api page under section ` Exchange a refresh token for an ID token `, we find the endpoint that we should target on refreshing the ` token `, the ` headers `, and ` body ` payload that should be attached.

* We will define a new ` Action ` to refresh the ` token `. However, we need first to store the ` refresh token `.
```js
export const storeToken = ( token, refreshToken, expiresIn ) => {
    return dispatch => {
        dispatch( setToken( token ) );
        AsyncStorage.setItem( "auth_token", token );
        AsyncStorage.setItem( "auth_refreshToken", refreshToken );

        const now = new Date();
        const expiryDateInMilliseconds = now.getTime() + expiresIn * 1000;

        AsyncStorage.setItem( "auth_expiryDate", expiryDateInMilliseconds.toString() );
    }
}
```
In ` authUser ` ` Action ` we pass the ` refreshToken ` to ` storeToken ` ` Action `.
```js
 dispatch( storeToken( parsedResponse.idToken, parsedResponse.refreshToken, parsedResponse.expiresIn ) );
```
Now we can define our new ` Action `.
```js
export const refreshIDToken = () => {
    return dispatch => {
        return new Promise( ( resolve, reject ) => {
            AsyncStorage.getItem( "auth_refreshToken" )
            .then( refreshToken => {
                if ( !refreshToken ) {
                    reject();
                    return;
                }

                return fetch("https://securetoken.googleapis.com/v1/token?key=" + API_KEY, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/x-www-form-urlencoded" 
                    },
                    body: "grant_type=refresh_token&refresh_token=" + refreshToken
                })
            } )
            .then( response => response.json() )
            .then( parsedResponse => {
                if ( !parsedResponse.id_token ) {
                    console.log( "no idToken" );
                    reject();
                }
                else {
                    resolve( parsedResponse );
                }
            } ).catch( error => {
                console.log( error );
                reject();
            } )
        } );
    }
};
```
The last thing to do is to ` dispatch ` ` refreshIdToken ` in ` getToken ` ` Action ` if we detected that the ` id token ` hs been expired.
```js
export const getToken = () => {
    return ( dispatch, getState ) => {
        const token = getState().authReducer.token;

        return new Promise( ( resolve, reject ) => {
            if ( !token ) {
                let gotToken;

                AsyncStorage.getItem( "auth_token" )
                    .then( tokenFromStorage => {
                        gotToken = tokenFromStorage;
                        if ( !gotToken ){
                            reject();
                            return;
                        }
                        return AsyncStorage.getItem( "auth_expiryDate" );
                    } )
                    .then( expiryDate  => {
                        if ( !expiryDate ) {
                            reject();
                            return;
                        }
                        const now = new Date();
                        const expiryDateObj = new Date( parseInt( expiryDate ) );
                        
                        if ( now < expiryDateObj ) {
                            dispatch( setToken( gotToken ) );
                            resolve( gotToken );
                            return;
                        }

                        return dispatch( refreshIDToken() )
                    } )
                    .then( response => {
                        if ( !response ) {
                            reject();
                            return;
                        }

                        dispatch( storeToken( response.id_token, response.refresh_token, response.expies_in ) )
                        resolve( response.id_token );
                    } )
                    .catch( error => {
                        reject();
                    } )
            }
            else {
                resolve( token );
            }
        } )
    };
};
```

## Adding User Logout
* We already have a Logout buton in the ` SideDrawerScreen `. We wish to add this functionality.

* To signup the user, we need to clear both the ` AsyncStorage ` and the ` token ` in the ` state ` and finally we need to redirect to the ` AuthScreen `.
    1. Create an ` Action ` that clears the ` token ` from ` state `.
        1. Give a name to the ` Action ` in ` ActionTypes `.
        ```js
        export const CLEAR_TOKEN = "CLEAR_TOKEN";
        ```
        
        2. Define the ` Action Creator `.
        ```js
        const clearToken = () => {
            return {
                type: CLEAR_TOKEN
            }
        };
        ```
        Do not forget to ` import ` ` CLEAR_TOKEN ` from ` ActionTypes `.

        3. Respond to that ` Action ` in ` redux/reducers/auth.js `.
        ```js
        case CLEAR_TOKEN:
            coppiedState.token = null;
            break;
        ```

    2. Create an ` Action ` that clears ` state ` and ` AsyncStorage ` and redirect. To redirect, we need to call ` startSingleScreenApp ` which we already have in ` App.js `.
        1. We ` export ` ` startSingleScreenApp ` by ` defalut `.
        ```js
        export default () => {
            Navigation.startSingleScreenApp({
            screen: {
                screen: "awesome_place.AuthScreen",
                title: "Login"
            }
            });
        }
        ```

        2. We need to call ` App ` in ` index.js `.
        ```js
        import App from './App';

        App();
        ```

        3. Now we can ` import ` ` App.js ` in ` redux/reducers/auth.js ` and define our target ` Action `.
        ```js
        export const logOut = () => {
            return dispatch => {
                dispatch( clearToken() );
                AsyncStorage.clear()
                    .then( () => {
                        App();
                    } );
            };
        };
        ```
        
        4. ` export ` this mew ` Action ` in ` redux/actions/index.js `.
        ```js
        export { authUser, getToken, autoSignIn, logOut } from './auth';
        ```

    3. We need to ` dispatch ` this new ` Action ` in ` SideDrawerScreen `.
        1. register ` SideDrawerScreen ` in ` App.js `.
        ```js
        Navigation.registerComponent( "awesome_places.SideDrawerScreen", 
            () => SideDrawerScreen,
            store,
            Provider );
        ```

        2. Define ` mapDispatchToProps ` and ` connect ` ` SideDrawerScreen `.
        ```js
        const mapDispatchToProps = dispatch => {
            return {
                onLogout: () => {
                    dispatch( logOut() );
                }
            }
        }

        export default connect( null, mapDispatchToProps )( SideDrawerScreen );
        ```
        Do not forget necessary ` imports `.
        ```js
        import { logOut } from '../redux/actions/index';
        import { connect } from 'react-redux';
        ```

        3. register the logout ` TouchableOpacity ` with ` onLogout `.
        ```js
        class SideDrawerScreen extends Component {
            render() {
                return(
                    <View style = { styles.container }>
                        <TouchableOpacity onPress = { this.props.onLogout() }>
                            <View style = { styles.logoutContainer }>
                                <Icon
                                    name = { Platform.OS === "android"? "md-log-out": "ios-log-out"}
                                    size={ 30 }
                                />
                                <MainText>
                                    <Text>Log Out</Text>
                                </MainText>
                            </View>
                        </TouchableOpacity>
                    </View>
                );
            }
        } 
        ```


## Refreshing the Token Without App Reloads
* Till now we handle all cases in login story except for one. What if the user left the application open in the background untill the ` token ` expired. On going back, we find the ` token ` in the ` state ` and then automaticall signin the user. The user tries to share a place and then boom!! It does not work. The ` token ` is expired.

* To solve that we need to store the ` expiryDate ` in the ` state ` and whenever we get the ` token ` from the ` state ` we check its expiry state. If it is expired, we get into the rest of the logic as if we could not find the ` token ` in the ` state `.
    1. Update ` setToken ` ` Action ` to store the ` expiryDate `.
    ```js
    export const setToken = (token, expiryDate) => {
        return {
            type: SET_TOKEN,
            payload: {
                token,
                expiryDate
            }
        }
    };
    ```
    
    2. Update the call to ` setToken ` in ` storeToken `.
    ```js
    export const storeToken = ( token, refreshToken, expiresIn ) => {
        return dispatch => {
            const now = new Date();
            const expiryDateInMilliseconds = now.getTime() + expiresIn * 1000;

            dispatch( setToken( token,  expiryDateInMilliseconds) );

            AsyncStorage.setItem( "auth_token", token );
            AsyncStorage.setItem( "auth_refreshToken", refreshToken );
            AsyncStorage.setItem( "auth_expiryDate", expiryDateInMilliseconds.toString() );
        }
    };
    ```

    3. Handle ` setToken ` and ` clearToken ` in the ` reducer `.
    ```js
    import { SET_TOKEN, CLEAR_TOKEN } from "../actions/ActionTypes";

    const initialState = {
        token: null,
        expiryDate: null
    };

    const authReducer = ( state = initialState, action ) => {
        let coppiedState = {
            ...state
        };

        switch ( action.type ) {
            case SET_TOKEN:
                coppiedState.token = action.payload.token;
                coppiedState.expiryDate = action.payload.expiryDate;
                break;
            case CLEAR_TOKEN:
                coppiedState.token = null;
                coppiedState.expiryDate = null;
                break;
        }

        return coppiedState;
    } ;

    export default authReducer;
    ```

    4. In ` getToken ` when getting the ` token ` from ` state ` check the expiry state. 
    ```js
    export const getToken = () => {
        return ( dispatch, getState ) => {
            const token = getState().authReducer.token;
            const expiryDate = getState().authReducer.expiryDate;
            const now = new Date();

            return new Promise( ( resolve, reject ) => {
                if ( !token || now < new Date( expiryDate ) ) {
                    //the rest of the function
    ```