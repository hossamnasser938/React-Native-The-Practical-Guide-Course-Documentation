# Diving into the Basics

## Module Introduction
* In this module we will look at the **basic building blocks** of a ` React Native ` app. Especially we will look at the following:
    * how to use the **base** ` Components ` provided by ` React Native ` as well as how to build our own ` Components ` using these base ones.
    * how to **style** ` Components `. We will not dive deep into **styling** since we have a dedicated module for that.
    * how to run our apps on a **simulator** and also on a **real device**.


## Creating a New Project
Nothing new. Everything here is mentioned in **Chapter 1: "Getting Started"** under **"Creating our First React Native App"**.


## JSX Elements You can and can't use
* After creating an app using ` create-react-native-app ` command, we have a file named ` App.js `. If we looked at this file we will find something that we are familiar with and another which is a bit new to us.
* The thing that we are familiar with is the ` App ` ` Component ` which is a normal ` React ` ` Component `.
    * Tip: We always ` import ` the ` React ` library like this:
    ```js
    import React from 'react';
    ```      
    and then we define a ` Component ` like this:
    ```js
    class App extends React.Component {}
    ```
    Instead we can reduce ` React.Component ` to ` Component ` by **importing** the ` Component ` like this:
    ```js
    import React, { Component } from 'react';
    ```
    ```js
    class App extends Component {}
    ```
* The new thing for us is the ` React Native ` stuff:
    ```js
    import { StyleSheet, Text, View } from 'react-native';
    ```
    * ` Text ` and ` View ` are basic ` React Native ` **components** which we can use and hence can be transformed on *building* and *compiling* to **native components**.
    * ` StyleSheet ` is what allows us to separate **components** *style* from the **JSX**. We use ` create ` method to create an **styling** object that wraps different styles of our ` components `:
      ```js
      const styles = StyleSheet.create();
      ```
      and then pass an object to ` create ` method that wraps styles of our ` components ` each as an inner object.
      ```js
      const styles = StyleSheet.create({
        container: {

        },
        simple_text: {

        }
      });
        ```
      Then we can reference those ` style ` objects in the **JSX** by ` styles.[name] `.


## Switching away from create-react-native-app
* Now let's switch from creating apps using ` create-react-native-app ` command to manually creating apps. This will allow us to run our application *natively* instead of letting ` Expo ` app wrap our application.
* To do that we search the web for ` React Native ` official documentation, go to ` Get started ` page and then we choose ` Building Projects with Native Code ` instead of the default selected ` Quick Start `.
* We follow the steps mentioned [there](https://facebook.github.io/react-native/docs/getting-started.html) to get every thing needed installed and create native apps.
* After following this guide, configuring Android Studio, and installing required dependencies, we can use ` React Native CLI ` to create a new project by hitting ` react-native init [project_name] `. Make sure to navigate first to the directory where we wanna create the project.


## Running the App on an Android Simulator(+ Setup)
* To run our app on an android simulator:
    1. Open Android Studio.
    2. Hit **open existing project**.
    3. Navigate to where your ` React Native ` project lives, open its directory. There you will find a directory named ` android ` which contains the native application generated by ` React Native ` which you can open using Android Studio as any Android native project.
    4. run the emulator.
    5. run your application by hitting ` react-native run-android `. Notice that you can add a script in the ` package.json ` file to specify a command you hit instead of ` react-native run-android `. Note that whatever command you choose to execute it, you should preceded it with ` npm run `. So for example if you specified your script like this: ` "android": "react-native run-android" `, you need to hit ` npm run android ` to run your application.
    6. Now you should see your application running on the emulator.


## Running our App on a Real Android Device
* All you need to do to run your application on a real device is to:
    1. Enable USB debugging in your phone.
    2. Connect your mobile with your PC using USB.
    3. Make sure that you closed the emulator.
    4. Run your application by hitting ` react-native run-android `.
    5. Now you should see your application running on your device. If something went wrong, you can follow [this](https://facebook.github.io/react-native/docs/running-on-device).
* To open the dev menu we can shake the device. Another way to do that(only if your device is connected using a USB) is to add a script in your ` package.json ` like this ` "devmenu":"adb shell input keyevent 82" ` and then hit ` npm run devmenu `. Refer to this [answer](https://stackoverflow.com/questions/49515325/open-dev-menu-or-reload-app-without-shaking).
* After running the application using **USB**, we can get rid of it and use wi-fi to **live** update our app. To do so:
    1. Make sure that your PC and mobile device are both connected on the same network.
    2. Open ` devmenu `.
    3. Hit ` Dev Settings `.
    4. Hit ` Debug server host && port for device `.
    5. Specify your PC ` IP ` and the ` PORT ` used ` IP:PORT `. To get the ` IP ` of your PC, hit ` ip add `.  


## A Good Development Setup
* On running your application on Android and IOS emulators, we can open the developer menu by hitting ` ctrl ` or ` cmd ` + ` m ` for **Android** or ` D ` for **IOS**. You can use this developer menu to:
    * ` Reload ` to reload your application manually. In the emulator, you can reload manually by hitting ` R ` twice on **Android** or ` cmd + R ` on **IOS**.  
    * Enable/Disable ` Live Reload `.
    * Enable/Disable ` Hot Reloading `.(Can not get the difference between ` Live ` and ` Hot ` ` Reloading `).
    * and more.
* To open this developer menu on a native device you can shake the phone.


## Working on the App _ Adding a TextInput
* We have a method named ` alert ` which does the same as the ` alert ` method of the browser which we are familiar with. It **alerts** something to the screen.
* Now let's add something to our app other than this normal ` Text ` ` Component `. Let's add something to get data from user which is a ` TextInput ` ` Component ` in ` React Native `.
    1. We start by importing this ` Component `.
    ```js
    import { StyleSheet, Text, View, TextInput } from 'react-native';
    ```
    2. let's add it to our ` App ` ` Component `.
    ```js
    render() {
      return(
        <View style={styles.container}>
          <TextInput />
        </View>
      );
    }
    ```
    3. Since ` React Native ` has no or little default styling, we must provide some styling for this to appear on the screen.
    ```js
    <TextInput style={ width:300, borderColor:"black", borderWidth:1 } />
    ```
    4. However the ` TextInput ` appears now and the user can type in it, we are not getting this input from the user. So let's capture the text entered by the user and store it in the ` state ` of this ` App ` ` Component `.
    ```js
    export default class App extends React.Component {
      state = {
        placeName: ""
      };

      onChangeTextHandler = inputVal => {
        this.setState( {
          placeName: inputVal
        } );
      };

      render() {
        return(
          <View style={ styles.container }>
            <TextInput style={ { width:300, borderColor:"black", borderWidth:1 } }
            value={ this.state.placeName }
            onChangeText={ this.onChangeTextHandler } />
          </View>
        );
      }
    }
    ```
    Note that the value of ` style ` prop of any ` Component ` is an object.
        * **Hint**: If we outputted the ` state ` object the line after calling ` setstate ` method, we do not get the last value set in ` setState `. Instead we get the value before calling ` setState ` which means, as I guess, ` setState ` method is **asynchronous**.  


## Styling _ Understanding the Basics
* We need to add a ` placeholder ` in the ` TextInput ` to give the user a **hint** about what should he inputs there. Fortunately, we have a ` prop ` named ` placeholder ` that let's us specify the placeholder text. In addition to that we have a prop named ` placeholderTextColor ` that lets us specify the color of the placeholder text. So let's use these ` props `.
```js
<TextInput style={ { width:300, borderColor:"black", borderWidth:1 } }
placeholder="Enter an Awesome Place"
placeholderTextColor="orange"
value={ this.state.placeName }
onChangeText={ this.onChangeTextHandler } />
```

* Now let's see how we position elements inside a ` Component ` or inside a wrapper ` View ` or generally in ` React Native ` apps.
    * ` React Native ` uses a concept called ` Flexbox ` to position elements.
    * ` Flexbox ` defines the layout by two **axes**: the **vertical axis** and the **horizontal axis**. One of those axes will be the **Main axis** or **Primary axis** and the other will be the **Cross axis** or **Secondary axis**. **You** are the one who specify which one is the **Main** and which is the **Cross**.
    * Using the attribute ` flexDirection `, you specify which is the **Main axis** and intuitively the other is the **Cross axis**. ` flexDirection ` has 2 possible values:
        * ` column ` which means the **vertical axis** is the **Main axis**. ` column ` is the **default** value.
        * ` row ` which means the **horizontal axis** is the **Main axis**.
    * Then we need a way to specify how the elements will be positioned in each axis.
        * ` justifyContent ` is the attribute used to specify how the elements will be positioned in the **Main axis**. ` justifyContent ` has 6  possible values:
            * ` flex-start ` means position items from the **start of Main axis**. ` flex-start ` is the **default** value.
            * ` flex-end ` means position items from the **end of Main axis**.
            * ` center ` means position items in the **center of Main axis**.
            * ` space-around ` later.
            * ` space-between ` means position items in the **Main axis** so that spaces between them are equal.
            * ` space-evenly ` later.
        * ` alignItems ` is the attribute used to specify how the elements will be positioned in the **Cross axis**. ` alighItems ` has 4  possible values:
            * ` flex-start ` means position items in the **start of Cross axis**.
            * ` flex-end ` means position items in the **end of Cross axis**.
            * ` center ` means position items in the **center of Cross axis**.
            * ` stretch ` means let each item stretch to **cover the full Cross axis**. ` stretch ` is the default value.
    * We need a **relative** value to define the **size** of each item **relative** to its siblings. ` flex ` attribute defines that. Possible values are integers. For example if we had two sibling items with ` flex ` equals 1 at both, so the available space will be divided among them equally. However, if the 1st has ` flex ` equals 2 and the 2nd has ` flex ` equals 1, then the available space will be divided such that the space of the 1st is twice as of the 2nd.

* Now let's practice this ` Flexbox ` things. First we had this ` JSX `:
```js
<View style={ styles.container }>
  <TextInput style={ { width:300, borderColor:"black", borderWidth:1 } }
  placeholder="Enter an Awesome Place"
  placeholderTextColor="orange"
  value={ this.state.placeName }
  onChangeText={ this.onChangeTextHandler } />
</View>
```  
with this styling:
```js
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
});
```
we notice the following:
    * ` flex ` is set to 1 and it has no siblings, which means it takes the whole space.
    * ` flexDirection ` is left to default which is ` column `.
    * Both ` justifyContent` and ` alignItems ` are set to ` center ` which means the ` TextInput ` is set in the center of both main(primary) and cross(secondary) axes.

* Now We need to position the ` TextInput ` at the most top instead of the center. To do that just change both ` justifyContent ` and ` alignItems ` to ` flex-start `.
```js
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'flex-start',
    justifyContent: 'flex-start',
  },
});
```
Doing this moves our ` TextInput ` to very top which leads to get it under the **status bar**. We add top ` padding ` or ` margin ` to solve this.
```js
const styles = StyleSheet.create({
  container: {
    flex: 1,
    paddingTop: 32,
    backgroundColor: '#fff',
    alignItems: 'flex-start',
    justifyContent: 'flex-start',
  },
});
```

* Another way to accomplish the same goal is to remove the ` flex ` attribute, add ` padding `, and leave everything as it was.
```js
const styles = StyleSheet.create({
  container: {
    paddingTop: 32,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
});
```
What happens here is when we removed ` flex ` attribute, the ` View ` now takes not the whole screen but the size of its inner elements which are only a ` TextInput `. This moves the ` View ` to the top. ` justifyContent ` now has no effect since the **Main axis** has no extra space.


## Positioning Elements with Flexbox
* Now we need to add a button next to our ` TextInput ` that lets the user adds a place.
    1. We need to ` import ` ` Button ` from ` 'react-native '`.
    ```js
    import {StyleSheet, View, TextInput, Button} from 'react-native';
    ```
    2. Now we make a ` Button ` ` Component ` and set its ` title ` attribute to ` Add `.
    ```js
    <Button
    title="Add" />
    ```
    3. But where to add this new ` Component ` in the **JSX** of the ` App ` ` Component `. Of course we say after ` TextInput ` ` Component ` like this:
    ```js
    <View style={styles.container}>
      <TextInput style={ { width:300, borderColor:"black", borderWidth:1 } }
      placeholder="Enter an Awesome Place"
      placeholderTextColor="orange"
      value={ this.state.placeName }
      onChangeText={ this.onChangeTextHandler } />

      <Button
      title="Add" />
    </View>
    ```
    However, this renders ` Button ` **below** ` TextInput ` since the attribute ` flexDirection ` is set to its default ` column ` in the parent ` View ` which means the **Main axis** is the vertical axis. To solve this we **wrap** the ` TextInput ` and the ` Button ` in a ` View ` and set its ` flexDirection ` attribute to ` row `.
    ```js
    <View style={styles.container}>
      <View style={ styles.input_container }>
        <TextInput style={ { width:"70%", borderColor:"black", borderWidth:1 } }
        placeholder="Enter an Awesome Place"
        placeholderTextColor="orange"
        value={ this.state.placeName }
        onChangeText={ this.onChangeTextHandler } />

        <Button
        style={ { width: "30%" } }
        title="Add" />
      </View>
    </View>
    ```
    Notice we can use **percent** values in ` width ` and ` height ` which gives us a great flexibility. We also added a new ` style ` object in the ` styles ` ` const `:
    ```js
    input_container: {
      width: "100%",
      flexDirection: "row",
      justifyContent: "space-between",
      alignItems: "center"
    }
    ```  
* **Hints**:
    * On running the application on a real device I sometimes get this error: ` Unable to load script from assets index.android.bundle `. For solution refer to this [answer](https://stackoverflow.com/questions/44446523/unable-to-load-script-from-assets-index-android-bundle-on-windows/44476757#44476757).
    * On trying to run the development server to run the application, I sometimes get this error: ` module HMRClient is not a registered callable module ` which is illustrated well in this [answer](https://github.com/expo/expo/issues/916): ` "X is not a registered callable module" happens when the native side of React Native tries to invoke a method of a JS module that hasn't been loaded. One reason this can happen is if your bundle fails to load e.g. because of a syntax error in it, or a JS error that happens early on during module initialization. This is something that tends to be different to each specific project and debugged individually. `.


## Adding a Button and Managing State
* Now after we added the ` Button ` ` Add ` that is intended to let the user adds places, we hope to actually let the user does so and also display the list of places he added till now.   
    1. We need to keep track of the places added in the ` state `.
        ```js
        state = {
          placeName: "",
          places: []
        };
        ```

    2. We need to define a method that adds the new place in ` places ` each time the user adds a new place by hitting the ` Button `.
        ```js
        addPlaceHandler = () => {
          if( this.state.placeName.trim() !== "" ) {
            this.setState( prevState => {
              return {
                places: prevState.places.concat( this.state.placeName )
              };
            } );
          }
        }
        ```
        Notice that we :
          * checked if the user entered an empty string.
          * we used ` setState ` method in a new way. We passed it not the ` newState ` but a ` function ` that accepts the ` prevState ` and returns the ` newState `. Notice also that We updated the ` prevState ` in an **immutable** way using ` concat ` method(This is important).

    3. We need to connect this method ` addPlaceHandler ` to the ` Button `. We use a ` prop ` named ` onPress `. It is the alternative of ` onClick ` in ` React `.
        ```js
        <Button
        style={ { width: "30%" } }
        title="Add"
        onPress={ this.addPlaceHandler } />
        ```

    4. Last before we ` return ` in the ` render ` method, we get our ` places ` ready by wrapping each ` place ` in a ` Text ` to be easily outputted in the **JSX**. We do so using ` map ` method.
        ```js
        render() {
          const placesTexts = this.state.places.map( (value, index) => 
            ( <Text key={ index }>{ value }</Text> ) );

          return (
            <View style={styles.container}>
              <View style={ styles.input_container }>
                <TextInput style={ { width:"70%", borderColor:"black", borderWidth:1 } }
                placeholder="Enter an Awesome Place"
                placeholderTextColor="orange"
                value={ this.state.placeName }
                onChangeText={ this.onChangeTextHandler } />
                <Button
                style={ { width: "30%" } }
                title="Add"
                onPress={ this.addPlaceHandler } />
              </View>
              <View>
                { placesTexts }
              </View>
            </View>
          );
        }
        ```
        Do not forget to ` import ` the ` Text ` ` Component `.
        ```js
        import {StyleSheet, View, Text, TextInput, Button} from 'react-native';
        ```
        **Hints**:
          * The default value of ` flexDirection ` attribute is ` column `, and since our ` View ` that wraps the ` places ` is set to default, ` places ` will be presented in a vertical list.
          * Whenever the ` state.places ` is changed by hitting the ` Button `, everything affected by it, is changed also so the ` placesTexts ` is updated and the **UI** is updated based on that update.      


## Creating a Custom Component
* Now We are successfully displaying a list of places that the user adds. However, we do not make any **styling** to this ` Text ` we use for each place in the list.
* Note that ` Text ` is a very little **stylable** ` Component `. You need to wrap it in a ` View ` to apply a specific **styling**. So it will be good to define a custom ` Component ` for a list item.
    1. To do that let's create a directory named ` src ` in the root directory of our application to wrap our source code. This makes our code base structured and prevent your root directory from getting too crowded. Under ` src ` we create a directory named ` components ` to wrap our custom ` components `.    
    2. In ` components ` we create a file named ` ListItem.js ` to define our custom ` Component `. Since this ` Component ` will just accept a string representing a list item, no need to define it as a **class-based** ` Component `. It is better to define it as a **functional** ` Component `.
    ```js
    import React from 'react';
    import { View, Text, StyleSheet } from 'react-native';

    const ListItem = ( props ) => (
      <View style={ styles.list_item }>
        <Text>{ props.placeName }</Text>
      </View>
    );

    const styles = StyleSheet.create( {
      list_item: {
        width: "100%",
        backgroundColor: "#eee",
        padding: 8,
        marginBottom: 8
      }
    } );

    export default ListItem;
    ```
    3. In `App.js ` we replace ` Text ` with ` ListItem `.
    ```js
    const placesTexts = this.state.places.map( (value, index) => ( <ListItem key={ index } placeName={ value }/> ) );
    ```
    Do not forget to ` import ` ` ListItem ` and now no need to ` import ` ` Text ` in ` App.js `.
    ```js
    import ListItem from './src/components/ListItem';
    ```
    We also add some styling to the ` View ` wrapping our ` ListItem `s.
    ```js
    list_container: {
      width: "100%",
      margin: 8
    }
    ```
    ```js
    <View style={ styles.list_container }>
      { placesTexts }
    </View>
    ```


## Time to Practice the Basics
* Now the time for the first assignment. We see our ` App ` ` Component ` got much bigger so we need to **decompose** it into multiple ` Components ` to make it more manageable.
    1. Let's start by separating the ` View ` that wraps the ` TextInput ` and the ` Button ` in a custom ` Component ` named ` AddPlace `. Since we still do not know how to use ` Redux ` in ` React Native `, we will handle ` state ` ourselves. We will leave the ` state ` as it is living in ` App ` ` Component ` and pass the methods that update this ` state ` as ` props ` to our new custom ` Component `.
      1. In ` AddPlace.js `.
          ```js
          import React from 'react';
          import { View, Button, TextInput, StyleSheet } from 'react-native';

          const AddPlace = ( props ) => (
            <View style={ styles.input_container }>
              <TextInput style={ { width:"70%", borderColor:"black", borderWidth:1 } }
              placeholder="Enter an Awesome Place"
              placeholderTextColor="orange"
              value={ props.placeName }
              onChangeText={ props.onChangeTextHandler } />

              <Button
              style={ { width: "30%" } }
              title="Add"
              onPress={ props.addPlaceHandler } />
            </View>
          )

          const styles = StyleSheet.create( {
            input_container: {
              width: "100%",
              flexDirection: "row",
              justifyContent: "space-between",
              alignItems: "center"
            }
          } );

          export default AddPlace;
          ```

        2. In ` App.js `. We need to ` import ` ` AddPlace ` ` Component `. Now no need to ` import ` ` Button ` nor ` TextInput ` in ` App.js `.
            ```js
            import AddPlace from './src/components/AddPlace';
            ```
            Now our **JSX** in ` App.js ` is reduced to this.
            ```js
            <View style={styles.container}>
              <AddPlace
              placeName={ this.state.placeName }
              onChangeTextHandler={ this.onChangeTextHandler }
              addPlaceHandler={ this.addPlaceHandler } />
              <View style={ styles.list_container }>
                { placesTexts }
              </View>
            </View>
            ```

    2. Let's now separate the whole list in a custom ` Component ` named ` PlacesList.js `.
        1. In ` PlacesList.js `.
        ```js
        import React from 'react';
        import { View, StyleSheet } from 'react-native';
        import ListItem from './ListItem';

        const PlacesList = ( props ) => {
          const placesTexts = props.places.map( (value, index) => ( <ListItem key={ index } placeName={ value }/> ) );

          return (
            <View style={ styles.list_container }>
              { placesTexts }
            </View>
          );
        }

        const styles = StyleSheet.create( {
          list_container: {
            width: "100%",
            margin: 8
          }
        } );

        export default PlacesList;
        ```
        2. In ` App.js `.
        We need to ` import ` ` PlacesList ` ` Component `. Now no need to ` import ` ` ListItem ` in ` App.js `.
        ```js
        import PlacesList from './src/components/PlacesList';
        ```
        Our ` render ` ` function ` is reduced to this.
        ```js
        render() {
          return (
            <View style={styles.container}>
              <AddPlace
              placeName={ this.state.placeName }
              onChangeTextHandler={ this.onChangeTextHandler }
              addPlaceHandler={ this.addPlaceHandler } />
              <PlacesList
              places = { this.state.places } />
            </View>
          );
        }
        ```


## Listening to Touch Events
* Till now the user **can add** places but he **can not remove** ones. We wish to let the user remove places by **touching** them. How can we respond to the user when touching a ` ListItem `?
* Unfortunately not all base ` components ` are **touchable**. Until now we are sure that:
    * ` Button ` is **touchable** and we respond to clicking on it by the ` onPress ` ` prop `.
    * ` View ` is **not touchable**.
* Fortunately, we have a way to make any ` Component ` **touchable** by wrapping it in a ` Touchable ` ` Component `. These ` components ` must have only one child so if you have more, wrap them in a ` View ` ` Component `. We have 4 ` Touchable ` ` components `:
    * ` TouchableWithoutFeedback `, as the name suggests, it is ` Touchable ` with no visual indication that it is touched.
    * ` TouchableHighlight ` and ` TouchableOpacity ` are both touched with a different visual indication.   
    * ` TouchableNativeFeedback ` is also touched with a visual indication **but** it is supported only on **Android** platform.
* Now let's make our ` ListItem ` **touchable**.
    1. In ` ListItem.js ` we wrap our ` View ` in a ` Touchable ` ` Component ` and set the ` onPress ` ` prop `.
    ```js
    const ListItem = ( props ) => (
      <TouchableOpacity onPress={ props.onItemPressHandler }>
        <View style={ styles.list_item }>
          <Text>{ props.placeName }</Text>
        </View>
      </TouchableOpacity>
    );
    ```
    2. In ` PlacesList.js ` we set the ` onItemPressHandler ` ` prop `.
    ```js
    const placesTexts = props.places.map( (value, index) =>
      ( <ListItem
        key={ index }
        placeName={ value }
        onItemPressHandler={ () => alert( `Item ${ index } pressed` ) }/>
      )
    );
    ```
    Here we just responded by an ` alert `. Soon we will respond by removing that pressed item.


## Reacting to Press Events
* Now instead of just ` alert ` something, we need to **remove** the place which is touched. Since places are stored in ` App ` ` Component ` ` state `, we have to define the ` function ` that removes the item touched there and then pass it to ` PlacesList ` ` Component ` to be registered with each ` ListItem ` in the list. This ` function ` will accept the **index** of the ` ListItem ` to be removed.  
    1. In ` App.js ` We define the ` function `. We will use the ` filter ` method which allows us to remove the item from ` places ` array in an **immutable** way.
    ```js
    removeItemHandler = ( id ) => {
      this.setState( prevState => {
        return {
          places: prevState.places.filter( ( v, i ) => i != id )
        }
      } );
    }
    ```
    We need to pass this ` function ` to ` PlacesList `.
    ```js
    <PlacesList
    places = { this.state.places }
    removeItemHandler = { this.removeItemHandler } />
    ```
    2. In ` PlacesList.js ` we register this ` function ` with each ` ListItem ` and pass the index of that ` ListItem `.
    ```js
    const placesTexts = props.places.map( (value, index) =>
      ( <ListItem
        key={ index }
        placeName={ value }
        onItemPressHandler={ () => props.removeItemHandler( index ) }/>
      )
    );
    ```


## Using a ScrollView
* Places added by the user may exceed the screen space so we need to let the user **scroll** up and down so that all places are there.
* To do that it is very simple. Just replace the ` View ` that wraps ` ListItem `s in ` PlacesList ` by ` ScrollView `.
```js
<ScrollView style={ styles.list_container }>
  { placesTexts }
</ScrollView>
```
Do not forget to ` import ` ` ScrollView ` instead of ` View `.
```js
import { ScrollView, StyleSheet } from 'react-native';
```
* ` ScrollView ` works nice when we know that our list will contain a few items. However, in bigger lists ` ScrollView ` has issues related to **performance** since it ` renders all its items at once `. This  is where ` FlatList ` comes into play.


## Rendering Lists Correctly
* ` FlatList ` is an alternative to ` ScrollView ` that ` renders list items lazily(only when needed) ` and this improves **performance** significantly.
* ` FlatList ` works in a different way than ` ScrollView `.
* In the case of ` ScrollView `, we prepare the items to be displayed by mapping them into ` components ` to be viewed in an array and wrap this array with a ` ScrollView `.
* In the case of ` FlatList `:
    1. we set the ` data ` ` prop ` to an array containing objects. Each object wraps: the item, and a unique key.
    2. we set the ` renderItem ` ` prop ` to a ` function ` that accepts ` info ` which is an object wrapping an ` item ` from the array passed to ` data ` ` props ` and other things such as ` separator ` and other things we will come to later. This ` function ` returns what to be rendered.
* Now let's replace our ` ScrollView ` with a ` FlatList `.
    1. In ` App.js `.  
        1. we change objects in ` places ` array.
        ```js
        addPlaceHandler = () => {
          if( this.state.placeName.trim() !== "" ) {
            this.setState( prevState => {
              return {
                places: prevState.places.concat( { key: Math.random(), value: this.state.placeName } )
              };
            } );
          }
        }
        ```
        Setting the ` key ` to ` Math.random() ` does not guarantee unique values but we will fix that later.  
        2. We need to update ` removeItemHandler ` method to ` filter ` based on the key not the index because now the key is not the index of the place. Instead it is generated using ` Math.random() `.
        ```js
        removeItemHandler = ( id ) => {
          this.setState( prevState => {
            return {
              places: prevState.places.filter( ( object ) => object.key != id )
            }
          } );
        }
        ```
    2. In ` PlacesList.js ` the **JSX** rendered becomes:
    ```js
    <FlatList
      style={ styles.list_container }
      data={ props.places }
      renderItem={ ( info ) => (
        <ListItem
          placeName={ info.item.value }
          onItemPressHandler={ () => props.removeItemHandler( info.item.key ) } />
      ) }
    />
    ```
    Do not forget To ` import ` ` FlatList ` instead of ` ScrollView `.
    ```js
    import { FlatList, StyleSheet } from 'react-native';
    ```
* Sometimes we have lists that are divided into **sections**. For these lists ` SectionList ` ` Component ` is a perfect fit.


## Adding Static Images
* Now we need to add images to our places. Let's try first to add a static image that we drag in our project to all places. Images stored locally can be ` imported ` or ` required ` and passed to ` source ` attribute of ` Image ` ` Component `.
    1. Let's first create a directory named ` assets ` in ` src ` directory. Then we drag our image there.
    2. In ` App.js `.
        1. let's ` import ` our image.
        ```js
        import ImageSource from './src/assets/beautiful-place.jpg';
        ```
        **Note** that ` React Native ` handles the ` Image ` path when deployed on the physical device since all our project is bundled so we won't still have this nice structure.
        2. Let's change the object stored in ` places ` array. We update ` value ` attribute to ` name ` and add ` image ` attribute.
        ```js
        addPlaceHandler = () => {
          if( this.state.placeName.trim() !== "" ) {
            this.setState( prevState => {
              return {
                places: prevState.places.concat(
                  { key: Math.random(),
                    name: this.state.placeName,
                    image: ImageSource
                  }
                )
              };
            } );
          }
        }
        ```
    3. In ` PlacesList.js ` we not only pass the place ` name ` but also the ` image `.  
    ```js
    <FlatList
      style={ styles.list_container }
      data={ props.places }
      renderItem={ ( info ) => (
        <ListItem
          placeName={ info.item.name }
          placeImage={ info.item.image }
          onItemPressHandler={ () => props.removeItemHandler( info.item.key ) } />
      ) }
    />
    ```
    4. In ` ListItem.js `.
        1. Let's ` import ` ` Image ` ` Component `.
        ```js
        import { View, Text, TouchableOpacity, Image, StyleSheet } from 'react-native';
        ```
        2. We change its **JSX** to include the ` Image `.
        ```js
        <TouchableOpacity onPress={ props.onItemPressHandler }>
          <View style={ styles.list_item }>
            <Image
              style={ styles.image }
              source={ props.placeImage } />
            <Text>{ props.placeName }</Text>
          </View>
        </TouchableOpacity>
        ```  
        3. We also add some style to the ` Image `.
        ```js
        image: {
          width: 30,
          height: 30,
          marginRight: 8
        }
        ```
        We specified the ` width ` and `height ` because if we did not, **JS** will render the ` Image ` with its `  width ` and ` height ` which is too big. If the ` Image ` is fetched from the web instead, **JS** will have no way to determine its ` width ` and ` height ` so we also need to specify them in that case. We also added some ` margin ` to keep the ` placeName ` away a little bit.  
        **Note** that we did not specify how the image will be resized. We actually did. ` Image ` has a ` prop ` named ` resizeMode ` and the default value of this ` prop `, which we use, is ` cover `.
        4. We also update the style of the wrapper ` View ` of the ` Image ` and the ` Text ` so that they sit next to each other.
        ```js
        list_item: {
          width: "100%",
          flexDirection: "row",
          alignItems: "center",
          backgroundColor: "#eee",
          marginBottom: 8
        }
        ```
        We do that by setting the attribute ` flexDirection ` to ` row ` instead of the default ` column ` and align ` Text ` center vertically by setting the ` alighItems ` attribute to ` center ` which is specific to the **Cross axis** which is the vertical axis here.


## Using Network Image
* Now we need to **fetch** our ` Image ` from the web instead of dragging it in our project. All we need to change is the object given to ` source ` attribute. Now no need to ` import ` anything, we just assign this ` source ` attribute an object with one attribute named ` uri ` and set its value to the **URL** of he ` Image `. In ` App.js ` remove the ` import ` of the local image and assign this atribute:
```js
addPlaceHandler = () => {
  if( this.state.placeName.trim() !== "" ) {
    this.setState( prevState => {
      return {
        places: prevState.places.concat(
          { key: Math.random(),
            name: this.state.placeName,
            image: {
              uri: "https://d27k8xmh3cuzik.cloudfront.net/wp-content/uploads/2017/09/shutterstock_351622814.jpg"
            }
          }
        )
      };
    } );
  }
}
```        


## Adding a Modal
* A ` Modal ` is a ` Component ` that can be viewed on top of other ` component `. A typical use case for a ` Modal ` is when you want the user on tapping on an ` Image `, it appears in the whole screen.
* A ` Modal ` is placed as the first child of the ` View ` that it will be displayed above.
* A ` Modal ` expects you to pass a ` prop ` named ` visible ` which is a ` boolean ` value that tells it whether to be displayed or not.
* A ` Modal ` in **Android** platform is preferred to be passed a value to a ` prop ` named ` onRequestClose ` which is a ` function ` to be called when the user hits ` back `. This ` function ` should close the ` Modal `.
* A ` Modal ` is optionally given a value to a ` prop ` named ` animationType ` which indicates what ` animation ` to be applied on opening and closing the ` Modal `. A possible value for this is ` slide ` which is not the default.  
* So let's let the user maximize the place ` Image ` and then decide whether to ` remove ` it or not there.
    1. First we wanna provide a way to identify when we should **display** the ` Modal ` and when we should not. One way to do that is to create a custom ` Component ` that wraps a ` Modal ` and is passed a value from ` App ` ` state ` which is the ` selectedPlace ` to be viewed. When this ` selectedPlace ` object is not ` null ` the ` Modal ` should display, when it is ` null ` the ` Modal ` should not display. This ` selectedPlace ` will be initialized with ` null ` and whenever the user hits a place we assign this ` selectedPlace ` the place the user just hit.
    ```js
    state = {
      placeName: "",
      selectedPlace: null,
      places: []
    };
    ```
    Now we need a method to display a place on hitting it rather than deleting it. This method will just assign a value from ` places ` array to the ` selectedPlace ` attribute. To do that we use ` find ` method which searches an array for a specific item. It is given a ` function ` that returns a condition that to be met on the target item.
    ```js
    selectItemHandler = ( key ) => {
      this.setState( prevState => {
        return {
          selectedPlace: prevState.places.find( place => place.key == key )
        }
      } );
    }
    ```
    We now pass this new method to ` PlacesList ` instead of the old method.
    ```js
    <PlacesList
      places = { this.state.places }
      selectItemHandler = { this.selectItemHandler }
    />
    ```
    In ` PlacesList.js `.
    ```js
    <ListItem
      placeName={ info.item.name }
      placeImage={ info.item.image }
      onItemPressHandler={ () => props.selectItemHandler( info.item.key ) } />
    ```
    2. Now we can add the ` Component ` that will wrap the ` Modal ` as the first child of the Main ` View ` in ` App.js `.
    ```js
    render() {
      return (
        <View style={styles.container}>
          <PlaceDetails
            selectedPlace={ this.state.selectedPlace }
            closeModalHandler={ this.closeModalHandler }
            removeItemHandler={ this.removeItemHandler }
          />
          <AddPlace
            placeName={ this.state.placeName }
            onChangeTextHandler={ this.onChangeTextHandler }
            addPlaceHandler={ this.addPlaceHandler }
          />
          <PlacesList
            places = { this.state.places }
            selectItemHandler = { this.selectItemHandler }
          />
        </View>
      );
    }
    ```
    3. The last thing left is to create the actual ` Component ` that wraps ` Modal ` which we named ` PlaceDetails `.
    ```js
    import React from 'react';
    import { Modal, View, Text, Image, Button, StyleSheet } from 'react-native';

    const PlaceDetails = props => {
      if( props.selectedPlace != null ) {
        var content = (
          <View style={ styles.modal_container }>
            <Image
              source={ props.selectedPlace.image }
              style={ styles.place_image }
            />
            <Text style={ styles.place_name }>{ props.selectedPlace.name }</Text>
            <Button
              title="Delete"
              style={ styles.delete_btn }
              color="red"
              onPress={ () => {
                  props.removeItemHandler( props.selectedPlace.key )
                  props.closeModalHandler()
                }
              }
            />
          </View>
        );
      }
      return(
        <Modal
          visible={ props.selectedPlace != null }
          onRequestClose={ props.closeModalHandler }
          animationType="slide">
          { content }
        </Modal>
      );
    }

    const styles = StyleSheet.create( {
        modal_container: {
          alignItems: "center",
        },
        place_image: {
          width: "80%",
          height: "50%",
          margin: 16
        },
        place_name: {
          fontWeight: "bold",
          fontSize: 28,
          marginBottom: 16
        }
      }
    );

    export default PlaceDetails;
    ```
    Note that the ` Modal ` is rendered even if its ` visible ` ` prop ` is ` false `. For that reason we need to decide further if we need to output something in it or not so we used the ` content ` variable that holds the content to be displayed if the ` Modal ` is ` visible ` and it is ` undefined ` when it should not display. If we injected the ` content ` directly without doing this check we will end up with the ` props.selectedPlace ` is ` null ` and we access attributes in ` null ` which leads to an error.


## React VS React Native
* A ` React Native ` app is still a ` React ` app. We still create ` React ` ` components `. For that reason everything applied on ` React ` apps is still applied on ` React Native ` apps including ` props `, ` state `, ` component lifecycle `, and more.
* The big difference is the ` components ` provided by ` React Native ` which are eventually transformed into **native UI**. Another big difference is the runtime environment. A ` React Native ` app runs on a mobile device not on a browser.


## JavaScript Supported Features
* Since ` React Native ` leaves logic of your app which is the ` JavaScript ` part not the part that is compiled into native code as it is. Which means it executes ` JavaScript ` on your device. This means that ` React Native ` handles many things for us like transpiling ` JavaScript ` code. This leads to classification of ` JavaScript ` that can be used and ` JavaScript ` that can not be used. To know what is supported and what is not, we should check the article in ` React Native ` documentation whose title is ` JavaScript Environment ` since this topic changes dramatically.      
